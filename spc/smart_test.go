package spc

import (
	"fmt"
	"reflect"
	"testing"
)

func TestParseSmartAttrs(t *testing.T) {
	tests := []struct {
		path string
		ex   []*smartAttr
	}{
		{
			"smart_attr_samsung_pm863.txt",
			[]*smartAttr{
				&smartAttr{5, 0x0033, 100, 100, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
				&smartAttr{9, 0x0032, 96, 96, []byte{0xCD, 0x40, 0x00, 0x00, 0x00, 0x00}, 16589, 0},
				&smartAttr{12, 0x0032, 99, 99, []byte{0x77, 0x00, 0x00, 0x00, 0x00, 0x00}, 119, 0},
				&smartAttr{177, 0x0013, 99, 99, []byte{0x2F, 0x00, 0x00, 0x00, 0x00, 0x00}, 47, 0},
				&smartAttr{179, 0x0013, 100, 100, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
				&smartAttr{180, 0x0013, 100, 100, []byte{0x37, 0x03, 0x00, 0x00, 0x00, 0x00}, 823, 0},
				&smartAttr{181, 0x0032, 100, 100, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
				&smartAttr{182, 0x0032, 100, 100, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
				&smartAttr{183, 0x0013, 100, 100, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
				&smartAttr{184, 0x0033, 100, 100, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
				&smartAttr{187, 0x0032, 100, 100, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
				&smartAttr{190, 0x0032, 68, 59, []byte{0x20, 0x00, 0x00, 0x00, 0x00, 0x00}, 32, 0},
				&smartAttr{194, 0x0022, 68, 59, []byte{0x20, 0x00, 0x19, 0x00, 0x29, 0x00}, 176095297568, 0},
				&smartAttr{195, 0x001A, 200, 200, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
				&smartAttr{197, 0x0032, 100, 100, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
				&smartAttr{199, 0x003E, 100, 100, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
				&smartAttr{202, 0x0033, 100, 100, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
				&smartAttr{235, 0x0012, 99, 99, []byte{0x4A, 0x00, 0x00, 0x00, 0x00, 0x00}, 74, 0},
				&smartAttr{241, 0x0032, 99, 99, []byte{0x9B, 0x46, 0xE8, 0x43, 0x02, 0x00}, 9729230491, 0},
				&smartAttr{242, 0x0032, 99, 99, []byte{0x2F, 0x53, 0x1B, 0x96, 0x00, 0x00}, 2518373167, 0},
				&smartAttr{243, 0x0032, 100, 100, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
				&smartAttr{244, 0x0032, 100, 100, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
				&smartAttr{245, 0x0032, 100, 100, []byte{0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00}, 65535, 0},
				&smartAttr{246, 0x0032, 100, 100, []byte{0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00}, 65535, 0},
				&smartAttr{247, 0x0032, 100, 100, []byte{0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00}, 65535, 0},
				&smartAttr{251, 0x0032, 100, 100, []byte{0x00, 0x9A, 0xDC, 0xEA, 0x05, 0x00}, 25415162368, 0},
			},
		},
		{
			"smart_attr_micron_5200.txt",
			[]*smartAttr{
				{1, 0x002F, 100, 100, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
				{5, 0x0032, 100, 100, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
				{9, 0x0032, 100, 100, []byte{0x7B, 0x1F, 0x00, 0x00, 0x00, 0x00}, 8059, 0},
				{12, 0x0032, 100, 100, []byte{0x1B, 0x00, 0x00, 0x00, 0x00, 0x00}, 27, 0},
				{170, 0x0033, 100, 100, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
				{171, 0x0032, 100, 100, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
				{172, 0x0032, 100, 100, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
				{173, 0x0032, 100, 100, []byte{0x01, 0x00, 0x00, 0x00, 0x00, 0x00}, 1, 0},
				{174, 0x0032, 100, 100, []byte{0x19, 0x00, 0x00, 0x00, 0x00, 0x00}, 25, 0},
				{183, 0x0032, 100, 100, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
				{184, 0x0032, 100, 100, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
				{187, 0x0032, 100, 100, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
				{188, 0x0032, 100, 100, []byte{0x1F, 0x00, 0x00, 0x00, 0x00, 0x00}, 31, 0},
				{194, 0x0022, 71, 67, []byte{0x1D, 0x00, 0x13, 0x00, 0x21, 0x00}, 141735165981, 0},
				{195, 0x0032, 100, 100, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
				{196, 0x0032, 100, 100, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
				{197, 0x0032, 100, 100, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
				{198, 0x0030, 100, 100, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
				{199, 0x0032, 100, 100, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
				{202, 0x0030, 100, 100, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
				{206, 0x000E, 100, 100, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
				{246, 0x0032, 100, 100, []byte{0x80, 0x0A, 0xC7, 0x01, 0x00, 0x00}, 29821568, 0},
				{247, 0x0032, 100, 100, []byte{0x57, 0x38, 0x0E, 0x00, 0x00, 0x00}, 931927, 0},
				{248, 0x0032, 100, 100, []byte{0xB7, 0xA6, 0x1C, 0x00, 0x00, 0x00}, 1877687, 0},
				{180, 0x0033, 0, 0, []byte{0xC0, 0xCB, 0x00, 0x00, 0x00, 0x00}, 52160, 0},
				{210, 0x0032, 100, 100, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
				{211, 0x0032, 100, 100, []byte{0x4A, 0x00, 0x00, 0x00, 0x00, 0x00}, 74, 0},
				{212, 0x0032, 100, 100, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, 0},
			},
		},
	}

	for _, test := range tests {
		t.Run(test.path, func(t *testing.T) {
			bytes, err := loadTestData(test.path)
			if err != nil {
				t.Errorf("%s %s", test.path, err)
			}

			got, err := parseSmartAttrs(bytes)
			if err != nil {
				t.Errorf("%s %s", test.path, err)
			}

			if len(got) != len(test.ex) {
				t.Errorf("test: %s len(got) %d, len(expect) %d", test.path, len(got), len(test.ex))
			} else {
				for i := 0; i < len(got); i++ {
					if !reflect.DeepEqual(got[i], test.ex[i]) {
						t.Errorf("got      %+v", got[i])
						t.Errorf("expected %+v", test.ex[i])
					}
				}
			}
		})
	}
}

func TestParseSmartThresholdsDict(t *testing.T) {
	tests := []struct {
		path string
		ex   map[byte]*smartThreshold
	}{
		{
			"smart_threshold_samsung_pm863.txt",
			map[byte]*smartThreshold{
				5:   &smartThreshold{5, 10, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				9:   &smartThreshold{9, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				12:  &smartThreshold{12, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				177: &smartThreshold{177, 05, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				179: &smartThreshold{179, 10, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				180: &smartThreshold{180, 10, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				181: &smartThreshold{181, 10, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				182: &smartThreshold{182, 10, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				183: &smartThreshold{183, 10, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				184: &smartThreshold{184, 97, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				187: &smartThreshold{187, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				190: &smartThreshold{190, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				194: &smartThreshold{194, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				195: &smartThreshold{195, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				197: &smartThreshold{197, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				199: &smartThreshold{199, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				202: &smartThreshold{202, 10, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				235: &smartThreshold{235, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				241: &smartThreshold{241, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				242: &smartThreshold{242, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				243: &smartThreshold{243, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				244: &smartThreshold{244, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				245: &smartThreshold{245, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				246: &smartThreshold{246, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				247: &smartThreshold{247, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				251: &smartThreshold{251, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				254: &smartThreshold{254, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				255: &smartThreshold{255, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
			},
		},
		{
			"smart_threshold_micron_5200.txt",
			map[byte]*smartThreshold{
				1:   &smartThreshold{1, 50, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				5:   &smartThreshold{5, 1, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				9:   &smartThreshold{9, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				12:  &smartThreshold{12, 1, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				170: &smartThreshold{170, 10, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				171: &smartThreshold{171, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				172: &smartThreshold{172, 1, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				173: &smartThreshold{173, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				174: &smartThreshold{174, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				183: &smartThreshold{183, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				184: &smartThreshold{184, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				187: &smartThreshold{187, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				188: &smartThreshold{188, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				194: &smartThreshold{194, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				195: &smartThreshold{195, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				196: &smartThreshold{196, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				197: &smartThreshold{197, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				198: &smartThreshold{198, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				199: &smartThreshold{199, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				202: &smartThreshold{202, 1, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				206: &smartThreshold{206, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				246: &smartThreshold{246, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				247: &smartThreshold{247, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				248: &smartThreshold{248, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				180: &smartThreshold{180, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				210: &smartThreshold{210, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				211: &smartThreshold{211, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
				212: &smartThreshold{212, 0, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
			},
		},
	}

	for _, test := range tests {
		t.Run(test.path, func(t *testing.T) {
			bytes, err := loadTestData(test.path)
			if err != nil {
				t.Errorf("%s %s", test.path, err)
			}

			got, err := parseSmartThresholdsDict(bytes)
			if err != nil {
				t.Errorf("%s %s", test.path, err)
			}

			if len(got) != len(test.ex) {
				t.Errorf("test: %s len(got) %d, len(expect) %d", test.path, len(got), len(test.ex))
			} else {
				for key := range got {
					if _, ok := test.ex[key]; !ok {
						t.Errorf("test: %s got has %x, expect does not have %x", test.path, key, key)
					}
					if !reflect.DeepEqual(got[key], test.ex[key]) {
						t.Errorf("test: %s got    -> %+v", test.path, got)
						t.Errorf("test: %s expect -> %+v", test.path, test.ex)
					}
				}
			}
		})
	}
}

func TestReadSmartTemp(t *testing.T) {
	var gotCur, gotMin, gotMax int16
	tests := []struct {
		in  []byte
		cur int16
		min int16
		max int16
	}{
		//  5  4  3  2  1  0 : Index
		// xx LL xx HH xx TT : Pattern 1
		// xx HH xx LL xx TT : Pattern 2
		// 00 00 HH LL xx TT : Pattern 3
		// 00 00 00 HH LL TT : Pattern 4
		{[]byte{0}, 0, 0, 0},                      // invalid pattern
		{[]byte{30, 0, 20, 0, 10, 0}, 30, 10, 20}, // Pattern 1
		{[]byte{30, 0, 10, 0, 20, 0}, 30, 10, 20}, // Pattern 2
		{[]byte{30, 0, 10, 20, 0, 0}, 30, 10, 20}, // Pattern 3
		{[]byte{30, 10, 20, 0, 0, 0}, 30, 10, 20}, // Pattern 4
	}

	for _, test := range tests {
		tt := test

		t.Run(fmt.Sprintf("%+v", tt), func(t *testing.T) {
			gotCur, gotMin, gotMax = readSmartTemp(tt.in)
			if gotCur != tt.cur || gotMin != tt.min || gotMax != tt.max {
				t.Errorf("test: %+v, got: cur=%d min=%d max=%d, expect: cur=%d min=%d max=%d", tt, gotCur, gotMin, gotMax, tt.cur, tt.min, tt.max)
			}
		})
	}
}

func TestReadRawVal(t *testing.T) {
	var got int64
	tests := []struct {
		in []byte
		ex int64
	}{
		{[]byte{2, 4, 8}, 0},
		{[]byte{2, 4, 8, 2, 4, 8}, 8813306971138},
		{[]byte{2, 4, 8, 0, 0, 0}, 525314},
		{[]byte{0, 0, 0, 0, 0, 0}, 0},
	}

	for _, test := range tests {
		tt := test

		t.Run(fmt.Sprintf("%+v", tt), func(t *testing.T) {
			got = readSmartRawVal(tt.in)
			if got != tt.ex {
				t.Errorf("test: %+v, got: %d, expect: %d", tt, got, tt.ex)
			}
		})
	}
}
